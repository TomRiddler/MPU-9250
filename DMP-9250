#include <Wire.h>
#include "MPU9250.h"

MPU9250 mpu9250;

void show()
{
  Serial.print(mpu9250.ACC_X); Serial.print("  "); 
  Serial.print(mpu9250.ACC_Y); Serial.print("  ");
  Serial.println(mpu9250.ACC_Z);
  Serial.print(mpu9250.Gyro_X); Serial.print("  "); 
  Serial.print(mpu9250.Gyro_Y); Serial.print("  ");
  Serial.println(mpu9250.Gyro_Z);
  Serial.print(mpu9250.Mag_X); Serial.print("  "); 
  Serial.print(mpu9250.Mag_Y); Serial.print("  ");
  Serial.println(mpu9250.Mag_Z); 
}

void setup()                 
{ 
 Serial.begin(115200);        
 Wire.begin();                              
 mpu9250.mpuconfig(2); //data config
}

void loop()
{
// mpu9250.readdata();//read data
// show();
// delay(1000);
uint16_t fifo_count = 0;
  while(1)//使用循环是为了等待DMP转换完成
  {   
    fifo_count = mpu9250.getFIFOCount();//读取FIFO计数
    //Serial.println(fifo_count);
    if(fifo_count >= 0x0200)//如果FIFO值>0x0200，此时DMP的结果错误，直接复位FIFO
    {
      mpu9250.resetFIFO();
    }
    else
    {
      if(fifo_count >= 0x2a)//如果FIFO值 > 0x2a,此时DMP转换完成并且数值正常
      { 
        mpu9250.ReadDmp(); //首先要读取DMP FIFO，读取之后才能进行计算姿态的操作
        mpu9250.resetFIFO();       
        mpu9250.getyawpitchroll();//计算并且获取yaw、pitch、roll，结果保存在yprf[3]数组中
        break;//转换并且计算完成之后退出循环*/
      } 
    }  
  }
  Serial.print(mpu9250.yprf[0]); Serial.print("  "); 
  Serial.print(mpu9250.yprf[1]); Serial.print("  ");
  Serial.println(mpu9250.yprf[2]);
  delay(100);
}
